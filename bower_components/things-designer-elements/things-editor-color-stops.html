<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="./things-editor-color.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <things-editor-color-stops type="gradient"
                               color-stops="{{gradient.colorStops}}">
    </things-editor-color-stops>

@demo demo/index-editor-color-stops.html
@hero hero.svg
-->

<dom-module id="things-editor-color-stops">
  <template>
    <style>
      :host {
        display: block;
        @apply(--things-editor-color-stops)
      }

      #color-stops {
        clear:both;
        margin-bottom:-8px;
        @apply(--things-editor-colorbar-container)
      }
      #colorbar {
        width:90%;
        height:12px;
        margin:auto;
        margin-bottom:25px;
        @apply(--things-editor-colorbar)
      }
      #markers {
        position:relative;
        top:30px;
        @apply(--things-editor-colorbar-markers)
      }
      #markers div {
        width:10px;height:10px;
        margin-top:-15px;
        position:absolute;
        border:2px solid #fff;
        cursor:pointer;
        -webkit-box-shadow: 1px 1px 1px 0px rgba(0,0,0,0.2);
        -moz-box-shadow:    1px 1px 1px 0px rgba(0,0,0,0.2);
        box-shadow:         1px 1px 1px 0px rgba(0,0,0,0.2);
        @apply(--things-editor-colorbar-marker)
      }
      #markers div:before {
        border-bottom:7px solid #fff;
        border-left:6px solid transparent;
        border-right:6px solid transparent;
        content: "";
        width:0;height:0;
        left:-1px;
        position: absolute;
        top: -7px;
      }
      #markers div[focused] {
        border-color:var(--things-editor-colorbar-marker-focused-color, #585858);
      }
      #markers div[focused]:before {
        border-bottom:7px solid var(--things-editor-colorbar-marker-focused-color, #585858);
      }
      input[type=color] {
        @apply(--things-editor-color-stops-input-color)
      }
      input[type=text] {
        @apply(--things-editor-color-stops-input-color-text)
      }
      input[type=number] {
        @apply(--things-editor-color-stops-input-position)
      }
      [draggable=true] {
        -khtml-user-drag: element;
      }
    </style>

    <div id="color-stops">
      <div id="colorbar">
        <div id="markers">
          <template id="markers-template" is="dom-repeat" items="[[colorStops]]">
            <div style$="background-color:[[item.color]];margin-left:[[_calculatePosition(item.position)]]px;" marker-index$="[[index]]" draggable=true>
            </div>
          </template>
        </div>
      </div>
    </div>

    <label>Color #</label>
    <things-editor-color id="color-editor" value="{{focused.color}}">
    </things-editor-color>

    <label>position</label>
    <input type="number" value-as-number="{{focused.position::change}}"/>

  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'things-editor-color-stops',

        behaviors: [
          Polymer.IronResizableBehavior
        ],

        properties: {
          /**
           * `type`은 color-stop bar의 표시 방법을 의미한다.
           * - 'solid' : 컬러스톱위치에서 다음 컬러스톱까지 solid color로 채운다.
           * - 'gradient' : 컬러스톱위치에서 다음 컬러스톱까지 gradient color로 채운다.
           */
          type: {
            type: String,
            value: "solid"
          },

          min: {
            type: Number,
            value: 0
          },

          max: {
            type: Number,
            value: 1
          },

          /**
           * `colorStops`은 color-stops에 의해 만들어진 color-stop 배열을 유지한다.
           */
          colorStops: {
            notify: true,
            value: [{
              position: 0,
              color: 'black'
            }, {
              position: 0.5,
              color: 'red'
            }, {
              position: 1,
              color: 'green'
            }],
          }
        },

        listeners: {
          'colorbar.dblclick': '_onDblClickColorbar',
          'markers.mousedown': '_onMouseDownMarkers',
          'markers.dblclick': '_onDblClickMarkers',
          'markers.dragstart': '_onDragStartMarkers',
          'markers.drag': '_onDragMarkers',
          'markers.dragend': '_onDragEndMarkers',
          'iron-resize': '_onIronResize'
        },

        observers: [
          '_onFocusedChanged(focused.*)',
          '_onChangeColorStops(colorStops.*)'
        ],

        _setFocused: function(index) {

          if(this.focused && this.focused.index === index)
            return

          /* 마커 템플릿을 다시 만든다. */
          this.$['markers-template'].render()
              
          var marker = this.$$('#markers div[focused]')
          if(marker)
            marker.removeAttribute('focused')

          marker = this.$$(`#markers div[marker-index='${index}']`)

          if(!marker) {
            this.focused = null
            return
          }

          marker.setAttribute('focused', true)

          var colorStop = this.colorStops[index]

          var position = colorStop.position
          if(position < this.min)
            position = this.min
          if(position > this.max)
            position = this.max
          
          this.focused = {
            index: index,
            color: colorStop.color,
            position: position,
            colorStop: colorStop
          }
        },

        _onFocusedChanged: function(change) {

          if(change.path === 'focused') {
            if(!change.value)
              this._setFocused(-1) // clear focused marker

            return
          }

          var property = change.path.substr(8)
          var value = change.value

          this.changedOnThis = true

          if(property === 'position') {
            var sorted = this.colorStops.sort(function(a, b) {
              return b.position < a.position
            })

            if(sorted[this.focused.index] !== this.focused.colorStop) {
              // 컬러스톱이 재배열되었다면..
              var index = -1
              for(var i = 0;i < sorted.length;i++) {
                if(sorted[i] === this.focused.colorStop) {
                  index = i
                  break
                }
              }
              
              this.set('colorStops', sorted)
              this._setFocused(index)
            } else {
              this.set(`colorStops.${this.focused.index}.${property}`, value);
            }
          } else {
            this.set(`colorStops.${this.focused.index}.${property}`, value);
          }

          this.changedOnThis = false
        },

        _onChangeColorStops: function() {

          if(!this.changedOnThis)
            this.focused = null

          var self = this

          if(this.type == 'gradient') {
            var stopsStrings = (this.colorStops || []).map(function(stop) {
              var position = (stop.position - self.min) / (self.max - self.min)
              return `${stop.color} ${position * 100}%`
            })            
          } else {
            var stops = this.colorStops || []
            var last = null
            var stopsStrings = stops.map(function(stop) {
              var stop_position = (stop.position - self.min) / (self.max - self.min)
              if(last) {
                var last_position = (last.position - self.min) / (self.max - self.min)
                var step = `${stop.color} ${last_position * 100}%, ${stop.color} ${stop_position * 100}%`
              } else {
                var step = `${stop.color} ${stop_position * 100}%`
              }
              last = stop
              return step
            })
            if(last)
              stopsStrings.push(`${last.color} ${last.position * 100}%, white ${last.position * 100}%, white 100%`)
          }

          var gradient = stopsStrings.join(',')

          this.$.colorbar.style.background = `linear-gradient(to right, ${gradient})` 
          /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */

          // `background: -webkit-linear-gradient(left, ${gradient});` /* Chrome10-25,Safari5.1-6 */
          // `background: -moz-linear-gradient(left, ${gradient});` /* FF3.6-15 */
        },

        _onDblClickColorbar: function(e) {
          /* 마커를 클릭한 경우를 걸러낸다. */
          if(e.target !== this.$.colorbar)
            return

          var width = this.$.colorbar.offsetWidth
          var position = e.offsetX / width
          var colorStops = this.colorStops ? this.colorStops.slice() : []


          for(var i = 0;i < colorStops.length;i++) {
            if(colorStops[i].position > position)
              break
          }

          colorStops.splice(i, 0, {
            position: position,
            color: '#FFFFFF'
          })

          this.colorStops = colorStops

          this.focused = null
          this._setFocused(i)
        },

        _onMouseDownMarkers: function(e) {
          var marker = e.target
          var index = marker.getAttribute('marker-index')

          this._setFocused(index)
        },

        _onDblClickMarkers: function(e) {
          this.$["color-editor"].showPicker()
        },

        _onDragStartMarkers: function(e) {
          var img = document.createElement("img")

          /* 빈 이미지. */
          img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
          e.dataTransfer.setDragImage(img, 0, 0)
          /* Firefox는 dataTransfer.setData를 해주지 않으면, drag 이벤트가 발생하지 않는다. */
          e.dataTransfer.setData('Text', 'for firefox')

          this.dragstart = {
            position: this.focused.position,
            screenX: e.screenX,
            screenY: e.screenY
          }
          // console.log('dragstart', e.screenX, e.pageX, e.offsetX, e.clientX)
        },

        _onDragMarkers: function(e) {
          var width = this.$.colorbar.offsetWidth

          // TODO Firefox는 마우스 드래깅 이벤트에서 마우스 좌표를 주지 않는다. (Firefox 버그)
          // 따라서, 부모 엘리먼트의 dragover 이벤트를 가지고 처리하는 방법으로 개선하자.
          // console.log('ondrag', e.screenX, e.pageX, e.offsetX, e.clientX)

          // TODO 이유는 모르겠으나, 마지막 드래그 이벤트에서 e.screenX값이 0가 됨. 그래서, 이것을 스킵함.
          if(e.screenX == 0)
            return

          var position = this.dragstart.position
            + ((e.screenX - this.dragstart.screenX) / width * (this.max - this.min))

          if(position > this.max)
            position = this.max
          else if(position < this.min)
            position = this.min

          this.set('focused.position', position)
        },

        _onDragEndMarkers: function(e) {
          /* 40 픽셀 이상 아래로 잡아당기면 삭제됨. */
          if(e.screenY - this.dragstart.screenY > 40) {
            this.colorStops.splice(this.focused.index, 1)
            this.colorStops = this.colorStops.slice()

            return
          }
        },

        _calculatePosition: function(position) {
          /* TODO 7 ==> 마커 폭의 절반으로 계산해야함. */
          var calculated = position
          
          if(calculated > this.max)
            calculated = this.max
          else if(calculated < this.min)
            calculated = this.min

          return (calculated - this.min) / (this.max - this.min) * this.$.colorbar.offsetWidth - 7
        },

        _onIronResize: function(e) {
          /* [더 좋은 방법으로 개선해주세요.]
           * 이 컴포넌트가 보이지 않는 상태에서 marker의 위치를 잡지 못하는 문제를 해결하기 위한 고육책
           * 그 원인은 컴포넌트가 보이지 않는 상태에서는 this.$.colorbar.offsetWidth 값이 0이기 떄문이다.
           */
          var width = this.$.colorbar.offsetWidth

          if(width > 0) {
            var template = this.$['markers-template']
            template.items = []
            template.render()
            template.items = this.colorStops
          }
          this._colorbar_size = width
        }

      })

    })();

  </script>
</dom-module>
